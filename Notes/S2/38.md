# TypeScript Type Safety in Angular Components

Let's update the `TasksComponent` to handle potentially undefined values safely. Here are the different approaches:

## 1. Optional Property with Question Mark

````typescript
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-tasks',
  standalone: true,
  imports: [],
  templateUrl: './tasks.component.html',
  styleUrl: './tasks.component.css',
})
export class TasksComponent {
  @Input() name?: string;
}
````

## 2. Union Type Approach

````typescript
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-tasks',
  standalone: true,
  imports: [],
  templateUrl: './tasks.component.html',
  styleUrl: './tasks.component.css',
})
export class TasksComponent {
  @Input() name: string | undefined;
}
````

## Update App Component to Handle Undefined Values

````typescript
import { Component } from '@angular/core';
// ...existing code...

@Component({
  // ...existing code...
})
export class AppComponent {
  users = DUMMY_USERS;
  selectedUserId = 'u1';

  get selectedUser() {
    return this.users.find(user => user.id === this.selectedUserId);
  }

  onSelectUser(userId: string) {
    this.selectedUserId = userId;
  }
}
````

## Safe Template Binding Options

1. **Optional Chaining**

````html
<app-tasks [name]="selectedUser?.name"></app-tasks>
````

2. **Ternary Expression**

````html
<app-tasks [name]="selectedUser ? selectedUser.name : ''"></app-tasks>
````

## Key Points

1. **Type Safety Approaches**
   - `?` for optional properties
   - `|` for union types
   - `?.` for safe property access

2. **Best Practices**
   - Avoid `!` unless truly certain
   - Handle undefined cases explicitly
   - Use union types for clarity

3. **Runtime Safety**
   - TypeScript prevents null/undefined errors
   - Safe property access prevents crashes
   - Fallback values ensure stable UI

4. **When to Use What**
   - `?` for optional class properties
   - `|` for explicit type unions
   - `?.` for optional chaining in templates
   - Ternary for fallback values

Remember: TypeScript's type system helps prevent runtime errors, but only if we use it correctly!
