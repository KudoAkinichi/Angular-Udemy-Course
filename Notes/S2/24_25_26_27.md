# Managing State & Change Detection in Angular

## Current Implementation

The `UserComponent` already demonstrates good state management practices:

1. **Computed Property Using Getter**

```typescript
get imagePath() {
    return 'assets/users/' + this.selectedUser.avatar;
}
```

2. **Event Handler for State Updates**

```typescript
onSelectUser() {
    const randomIndex = Math.floor(Math.random() * DUMMY_USERS.length);
    this.selectedUser = DUMMY_USERS[randomIndex];
}
```

## Let's Enhance the Component

Update user.component.ts to add more functionality:

````typescript
import { Component } from '@angular/core';
import { DUMMY_USERS } from '../dummy-users';

@Component({
  selector: 'app-user',
  standalone: true,
  imports: [],
  templateUrl: './user.component.html',
  styleUrl: './user.component.css'
})
export class UserComponent {
  selectedUser = DUMMY_USERS[Math.floor(Math.random() * DUMMY_USERS.length)];
  previousUsers: typeof DUMMY_USERS[0][] = [];

  get imagePath() {
    return 'assets/users/' + this.selectedUser.avatar;
  }

  get canUndo() {
    return this.previousUsers.length > 0;
  }

  onSelectUser() {
    // Store current user before changing
    this.previousUsers.push(this.selectedUser);
    
    // Select new random user
    let newIndex: number;
    do {
      newIndex = Math.floor(Math.random() * DUMMY_USERS.length);
    } while (DUMMY_USERS[newIndex].id === this.selectedUser.id);
    
    this.selectedUser = DUMMY_USERS[newIndex];
  }

  onUndoSelection() {
    if (this.canUndo) {
      this.selectedUser = this.previousUsers.pop()!;
    }
  }
}
````

Update the template:

````html
<div class="user-card">
  <img [src]="imagePath" [alt]="selectedUser.name">
  <h2>{{ selectedUser.name }}</h2>
  <div class="actions">
    <button (click)="onSelectUser()">Select Random User</button>
    <button 
      (click)="onUndoSelection()" 
      [disabled]="!canUndo">
      Undo
    </button>
  </div>
</div>
````

## Key Concepts

1. **State Management**
   - Component state stored in properties
   - Changes trigger Angular's change detection
   - UI updates automatically reflect state changes

2. **Change Detection**
   - Handled by Zone.js
   - Monitors events automatically
   - Updates DOM when state changes

3. **Best Practices**
   - Use getters for computed values
   - Keep templates simple
   - Handle complex logic in component class
   - Maintain immutable state patterns

4. **Performance**
   - Angular optimizes change detection
   - Use `OnPush` strategy for better performance
   - Avoid complex computations in getters
