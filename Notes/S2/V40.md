
````markdown
# TypeScript: Interface vs Type Alias (2019 Update)

The current answers and even some official documentation are outdated.  
For those new to TypeScript, the terminology can be confusing without examples.  

Below is an up-to-date list of differences.

---

## 1. Objects / Functions

Both **interfaces** and **type aliases** can describe the shape of an object or a function signature.  
But the **syntax differs**.

### Interface
```ts
interface Point {
  x: number;
  y: number;
}

interface SetPoint {
  (x: number, y: number): void;
}
````

### Type Alias

```ts
type Point = {
  x: number;
  y: number;
};

type SetPoint = (x: number, y: number) => void;
```

---

## 2. Other Types

Unlike an interface, a **type alias** can also be used for other types such as primitives, unions, and tuples.

```ts
// primitive
type Name = string;

// object
type PartialPointX = { x: number };
type PartialPointY = { y: number };

// union
type PartialPoint = PartialPointX | PartialPointY;

// tuple
type Data = [number, string];
```

---

## 3. Extend

Both can be extended, but again, the syntax differs.
Also, interfaces and type aliases are **not mutually exclusive**.
An interface can extend a type alias, and vice versa.

### Interface extends Interface

```ts
interface PartialPointX { x: number; }
interface Point extends PartialPointX { y: number; }
```

### Type Alias extends Type Alias

```ts
type PartialPointX = { x: number };
type Point = PartialPointX & { y: number };
```

### Interface extends Type Alias

```ts
type PartialPointX = { x: number };
interface Point extends PartialPointX { y: number; }
```

### Type Alias extends Interface

```ts
interface PartialPointX { x: number; }
type Point = PartialPointX & { y: number };
```

---

## 4. Implements

A **class** can implement an interface or a type alias, in the same way.
⚠️ However, a class **cannot** implement a type alias that names a **union type**.

```ts
interface Point {
  x: number;
  y: number;
}

class SomePoint implements Point {
  x = 1;
  y = 2;
}

type Point2 = {
  x: number;
  y: number;
};

class SomePoint2 implements Point2 {
  x = 1;
  y = 2;
}

type PartialPoint = { x: number } | { y: number };

// ❌ Cannot implement a union type
class SomePartialPoint implements PartialPoint {
  x = 1;
  y = 2;
}
```

---

## 5. Declaration Merging

Unlike a type alias, an **interface** can be defined multiple times.
All declarations are merged into a single interface.

```ts
// These two declarations merge into:
// interface Point { x: number; y: number; }

interface Point { x: number; }
interface Point { y: number; }

const point: Point = { x: 1, y: 2 };
```

---

# ✅ Summary Table: Interface vs Type Alias

| Feature                    | Interface ✅                    | Type Alias ✅                      |
| -------------------------- | ------------------------------ | --------------------------------- |
| **Describes objects**      | ✔️                             | ✔️                                |
| **Describes functions**    | ✔️                             | ✔️                                |
| **Supports primitives**    | ❌                              | ✔️                                |
| **Supports unions**        | ❌                              | ✔️                                |
| **Supports tuples**        | ❌                              | ✔️                                |
| **Extends other types**    | ✔️ (interfaces & type aliases) | ✔️ (interfaces & type aliases)    |
| **Implemented by classes** | ✔️                             | ✔️ (except union types)           |
| **Declaration merging**    | ✔️                             | ❌                                 |
| **Best for**               | Object contracts, APIs         | Complex types, unions, primitives |

---

✅ **Rule of Thumb**:

* Use **interfaces** for **objects, APIs, and class contracts**.
* Use **type aliases** when you need **unions, primitives, or advanced type composition**.

Key Takeaways
Type aliases in TypeScript allow outsourcing complex types using the type keyword.
Interfaces provide an alternative way to define object types using the interface keyword.
Both type aliases and interfaces can be used to define object shapes, with interfaces limited to objects.
The choice between type aliases and interfaces often depends on personal or project conventions, such as Angular favoring interfaces.
