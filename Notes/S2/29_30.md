# Converting to Signal Inputs in Angular

Let's update the `UserComponent` to use Signal Inputs instead of the decorator approach:

1. **Update User Component with Signal Inputs**

````typescript
import { Component, computed, input } from '@angular/core';

@Component({
  selector: 'app-user',
  standalone: true,
  imports: [],
  templateUrl: './user.component.html',
  styleUrl: './user.component.css',
})
export class UserComponent {
  // Replace @Input decorator with input() function
  avatar = input.required<string>();
  name = input.required<string>();

  // Use computed() for derived values
  imagePath = computed(() => 'assets/users/' + this.avatar());
}
````

2. **Update User Template for Signal Syntax**

````html
<div class="user-card">
  <img [src]="imagePath()" [alt]="name()">
  <h2>{{ name() }}</h2>
</div>
````

## Key Changes Explained

### 1. Signal Input Creation

- Removed `@Input()` decorators
- Using `input.required<string>()` for required inputs
- No need for non-null assertion operator (`!`)

### 2. Computed Values

- Replaced getter with `computed()`
- More efficient than getter-based approach
- Automatically tracks signal dependencies

### 3. Template Updates

- Added function calls `()` to read signals
- Applied to both interpolation and property binding
- Example: `{{ name() }}` instead of `{{ name }}`

## Benefits of Signal Inputs

1. **Type Safety**
   - Better TypeScript integration
   - No need for non-null assertions
   - Clear input requirements

2. **Performance**
   - Fine-grained reactivity
   - Efficient change detection
   - Optimized re-rendering

3. **Read-Only Protection**
   - Inputs can't be modified internally
   - Clearer data flow
   - Better encapsulation

## Usage Notes

- Signal inputs are read-only
- Can't use `set()` on input signals
- Parent component binding remains the same:

  ```html
  <app-user [name]="userData.name" [avatar]="userData.avatar">
  </app-user>
  ```

*Note: Signal inputs are available in Angular 17+. Consider project compatibility before adoption.*
